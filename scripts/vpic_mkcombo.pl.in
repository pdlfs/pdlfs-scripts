#!/usr/bin/env perl

#
# Copyright (c) 2019 Carnegie Mellon University,
# Copyright (c) 2019 Triad National Security, LLC, as operator of
#     Los Alamos National Laboratory.
#
# All rights reserved.
#
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file. See the AUTHORS file for names of contributors.
#

#
# vpic_mkcombo.pl  combine vpic batch experiments into a single one
# 12-Mar-2018  chuck@ece.cmu.edu
#

use strict;
use Getopt::Long qw(:config require_order);

my($rv, $outfile, $tag, $outhand);

$rv = GetOptions(
    "output=s" => \$outfile,
    "tag=s"    => \$tag,
    );

sub usage {
    my($msg) = @_;
    print STDERR "ERR: $msg\n" if ($msg ne '');
    print STDERR "usage: vpic_mkcombo [options] input1 input2 ...\n";
    print STDERR "general options:\n";
    print STDERR "\t--output S    specify an output file\n";
    print STDERR "\t--tag S       specify a jobname tag\n";
    exit(1);
}

usage() if ($rv != 1);
usage("missing input file list") if ($#ARGV == -1);
$tag = "-$tag" if ($tag ne '');     # add sep

my($prefix, $in, @hdr, $mode, %state, $lcv, $subdir);
$prefix = '@CMAKE_INSTALL_PREFIX@';

#
# walk the inputs
#
foreach $in (@ARGV) {
    @hdr = get_header($in);
    $mode = $hdr[0] if ($mode eq '');
    usage("$in is wrong type (want $mode, got $hdr[0])")
        if ($mode ne $hdr[0]);

    if ($mode eq 'slurm') {
        addstate_slurm($in, \%state, \@hdr);    # will abort on error
    } elsif ($mode eq 'moab') {
        addstate_moab($in, \%state, \@hdr);     # will abort on error
    }

}

#
# generate the output
#
if ($outfile ne '') {
    open($outhand, ">$outfile") || die "can't open output $outfile";
} else {
    $outhand = \*STDOUT;
}

print $outhand "#!/bin/bash\n";
print $outhand "# generated by vpic_mkcombo.pl\n";
print $outhand "# inputs: ", join(" ", @ARGV), "\n";
if ($mode eq 'slurm') {
    print $outhand "#SBATCH --job-name vpic-combo$tag\n";
    printf $outhand "#SBATCH --time=%d:%02d:00\n",
        int($state{'time'} / 60), $state{'time'} % 60;
    printf $outhand "#SBATCH --nodes=%d\n", $state{'nodes'};
    printf $outhand "#SBATCH --constraint=%s\n", $state{'constraint'}
        if ($state{'constraint'} ne '');
    printf $outhand "#SBATCH --core-spec=%s\n", $state{'core-spec'}
        if ($state{'core-spec'} ne '');
    print $outhand
        "#SBATCH --output /users/%u/joblogs/vpic-combo$tag-%j.out\n";
    printf $outhand "#SBATCH --partition=%s\n", $state{'partition'}
        if ($state{'partition'} ne '');
} elsif ($mode eq 'moab') {
    print $outhand "#MSUB -N vpic-combo$tag\n";
    printf $outhand "#MSUB -l walltime=%d:%02d:00\n",
        int($state{'walltime'} / 60), $state{'walltime'} % 60;
    if ($state{'constraint'} eq '') {
        printf $outhand "#MSUB -l nodes=%d\n", $state{'nodes'};
    } else {
        printf $outhand "#MSUB -l nodes=%d:%s\n",
               $state{'nodes'}, $state{'constraint'};
    }
   print $outhand
       "#MSUB -o /users/\$USER/joblogs/vpic-combo$tag-\$MOAB_JOBID.out\n";
   print $outhand "#MSUB -j oe\n";
}
print $outhand $state{'dw'}, "\n" if ($state{'dw'} ne '');

print $outhand "\n";

print $outhand "export OMP_NUM_THREADS=1   # to be safe\n";
print $outhand "unset LANG                 # avoid bash bug\n";
print $outhand "module load dws\n" if ($state{'dw'} ne '');
print $outhand "\n";
print $outhand ". $prefix/scripts/common.sh\n\n";

print $outhand "get_jobdir                    # this sets jobdir\n";
print $outhand "origjobdirhome=\$JOBDIRHOME    # save orig value\n";
print $outhand "origjobdir=\$jobdir\n";
print $outhand "\n";

for ($lcv = 0 ; $lcv <= $#ARGV ; $lcv++) {
    $in = $ARGV[$lcv];
    $subdir = $in;
    $subdir =~ s/.*\///;
    $subdir =~ s/\.sh$//;
    $subdir = "subjob-${lcv}-$subdir";
    print $outhand "echo starting $in...\n";
    print $outhand "export JOBDIRHOME=\$jobdir/$subdir\n";
    print $outhand "get_bbdir    # update bbdir\n" if ($state{'dw'} ne '');
    print $outhand 'do_mpirun 1 1 "none" "" "" "rm -rf ${bbdir}"' . "\n"
        if ($state{'dw'} ne '');
    print $outhand "$in 2>&1 | \\\n";
    print $outhand "    tee \${origjobdir}/${subdir}.out\n";
    print $outhand "export JOBDIRHOME=\$origjobdirhome\n";
    print $outhand "echo done $in\n";
    print $outhand "\n";
}

print $outhand "exit 0\n";

if ($outfile ne '') {
    close($outhand);
    system "chmod", "a+x", $outfile;
}

exit(0);

#
# get_header: load in the header of a batch file
#
sub get_header {
    my($file) = @_;
    my($hand, @rv, $t);
    open($hand, $file) || usage("cannot open $file ($!)");
    $rv[0] = 'unknown';
    while (<$hand>) {
        last unless (/^#/);
        chop;

        # determine current line type
        if (/^#MSUB/) {
            $t = 'moab';
        } elsif (/^#SBATCH/) {
            $t = 'slurm';
        } elsif (/not using batch system/) {
            $t = 'mpi';
        }

        # set type in $rv[0] if we've found it
        $rv[0] = $t if ($rv[0] eq 'unknown' && $t ne '');

        # cross check
        usage("type mismatch in $file - $t != $rv[0]")
            if ($t ne '' && $t ne $rv[0]);

        push(@rv, $_);
    }
    close($hand);
    usage("couldn't determine type of file $file")
        unless ($rv[0] ne 'unknown');
    usage("$file doesn't start with #!") unless ($rv[1] =~ /^#!/);
    return(@rv);
}

#
# addstate_slurm(input,stateref,hdrref): add/check slurm state
#
sub addstate_slurm {
    my($i, $sr, $hr) = @_;
    my($dw, %flgs, $isnew, $hour, $min);

    foreach (@$hr) {
        if (/^#DW/) {
            $dw = $_;
            next;
        }
        next unless (/^#SBATCH/ && /--([\w|-]+)[=|\s+](.*)/);
        $flgs{$1} = $2;
    }
    $flgs{'dw'} = $dw if ($dw ne '');    # fold this in

    $isnew = ($$sr{'mode'} eq '');
    $$sr{'mode'} = $$hr[0];

    if ($flgs{'time'} =~ /(\d+):(\d+):(\d+)/) {
        $$sr{'time'} += (($1 * 60) + $2);
    } else {
        die "$i - can't find/parse time";
    }
    if ($flgs{'nodes'} =~ /(\d+)/) {
        if ($1 > $$sr{'nodes'}) {
            $$sr{'nodes'} = $1;
            print STDERR "$i increases node count to $1\n";
        }
    } else {
        die "$i - can't find/parse node count";
    }

    if ($isnew) {
        $$sr{'constraint'} = $flgs{'constraint'}
            if (defined($flgs{'constraint'}));
        $$sr{'core-spec'} = $flgs{'core-spec'}
            if (defined($flgs{'core-spec'}));
        $$sr{'partition'} = $flgs{'partition'}
            if (defined($flgs{'partition'}));
        if (defined($flgs{'dw'}) && $flgs{'dw'} =~ /capacity=(\w+)/) {
            print STDERR "$i increase DW size to $1\n";
            $$sr{'dw'} = $flgs{'dw'};
        }
        return;
    }
    die "$i constraint mismatch"
        if ($flgs{'constraint'} ne $$sr{'constraint'});
    die "$i core-spec mismatch"
        if ($flgs{'core-spec'} ne $$sr{'core-spec'});
    die "$i partition mismatch"
        if ($flgs{'partition'} ne $$sr{'partition'});
    die "$i dw on/off mismatch"
        if (($flgs{'dw'} eq '' && $$sr{'dw'} ne '') ||
            ($flgs{'dw'} ne '' && $$sr{'dw'} eq ''));
    $$sr{'dw'} = dwmax($i, $$sr{'dw'}, $flgs{'dw'}) if ($flgs{'dw'} ne '');
}

#
# dwmax(file,current,new): sanity check dw and track max allocation
#
sub dwmax {
    my($i, $a0, $b0) = @_;
    my($a, $b, $asz, $bsz) = ($a0, $b0);
    die "missing dw cap $i" unless ($a =~ s/capacity=(\w+)//);
    $asz = $1;
    die "missing dw cap $i" unless ($b =~ s/capacity=(\w+)//);
    $bsz = $1;
    die "dw mismatch in $i" if ($a ne $b);
    if (mib($bsz) > mib($asz)) {
        print STDERR "$i increase DW size to $bsz!\n";
        return($b0);
    }
    return($a0);
}

#
# mib: convert size spec to mib
#
sub mib {
    my($spec) = @_;
    die "bad mib spec $spec" unless ($spec =~ /(\d+)(MiB|GiB|TiB)/);
    return($1) if ($2 eq 'MiB');
    return($1*1024) if ($2 eq 'GiB');
    return($1*1024*1024) if ($2 eq 'TiB');
    die "this can't happen";
}

#
# addstate_moab(input,stateref,hdrref): add/check moab state
#
sub addstate_moab {
    my($i, $sr, $hr) = @_;
    my($dw, %flgs, $isnew, $hour, $min);

    foreach (@$hr) {
        if (/^#DW/) {
            $dw = $_;
            next;
        }
        next unless (/^#MSUB/);
        if (/walltime=(\d+):(\d+):(\d+)/) {
            $flgs{'walltime'} = ($1 * 60) + $2;
            next;
        }
        if (/nodes=(\d+):(\S+)/) {
            $flgs{'nodes'} = $1;
            $flgs{'constraint'} = $2;
            next;
        }
        if (/nodes=(\d+)/) {
            $flgs{'nodes'} = $1;
            next;
        }
    }
    $flgs{'dw'} = $dw if ($dw ne '');    # fold this in

    $isnew = ($$sr{'mode'} eq '');
    $$sr{'mode'} = $$hr[0];

    if ($flgs{'walltime'} > 0) {
        $$sr{'walltime'} += $flgs{'walltime'};
    } else {
        die "$i - can't find/parse walltime";
    }
    if ($flgs{'nodes'} > 0) {
        if ($flgs{'nodes'} > $$sr{'nodes'}) {
            $$sr{'nodes'} = $flgs{'nodes'};
            printf STDERR "$i increases node count to %d\n", $flgs{'nodes'};
        }
    } else {
        die "$i - can't find/parse node count";
    }

    if ($isnew) {
        $$sr{'constraint'} = $flgs{'constraint'}
            if (defined($flgs{'constraint'}));
        if (defined($flgs{'dw'}) && $flgs{'dw'} =~ /capacity=(\w+)/) {
            print STDERR "$i increase DW size to $1\n";
            $$sr{'dw'} = $flgs{'dw'};
        }
        return;
    }

    die "$i constraint mismatch"
        if ($flgs{'constraint'} ne $$sr{'constraint'});

    die "$i dw on/off mismatch"
        if (($flgs{'dw'} eq '' && $$sr{'dw'} ne '') ||
            ($flgs{'dw'} ne '' && $$sr{'dw'} eq ''));
    $$sr{'dw'} = dwmax($i, $$sr{'dw'}, $flgs{'dw'}) if ($flgs{'dw'} ne '');
}
